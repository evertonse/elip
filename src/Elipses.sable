Package elipses;

Helpers
  digit     = ['0' .. '9'];
  bin_digit = ('0' | '1');

  letter    = [['a' .. 'z'] + ['A' .. 'Z']];
  nondigit	=	[ '_' + letter ];

  any = [0x0 .. 0xfffff];
  ascii_char = [32 .. 127] ;

  // empty
  cr = 13 ; // carriage return
  lf = 10 ; // line feed
  tab = 9 ; // tab char
  space = ' ';
  nl = '\n';
  eol = lf | cr | cr lf;
  not_eol = [any - [cr + lf]];
  not_minus = [any - '-'];
  not_minus_not_r_curly = [not_minus - '}'];

  hashtag = '#';

  // Brackets
  comma   = ',';
  l_curly = '{';
  r_curly = '}';  
  l_paren = '(';
  r_paren = ')';
  l_brack = '[';
  r_brack = ']';

  l_curly_double_minus = '{--';
  r_curly_double_minus = '--}';
  
  // Comments
  comment_line  = '#' not_eol* eol;
  comment_line_eof  = '#' not_eol* eol?;
  comment_block = l_curly_double_minus  not_minus* '-'+ (not_minus_not_r_curly not_minus*  '-'+)* '-}';  
 


//+-------------------------------------------------------------+
//| Tokens (Regex) 
//+-------------------------------------------------------------+
 
Tokens
/* These are token definitions. It is allowed to use helper regular *
 * expressions in the body of a token definition.                   *
 * On a given input, the longest valid definition is chosen, In     *
 * case of a match, the definition that appears first is chosen.    *
 * Example: on input -> 's' <- "char" will have precedence on       *
 * "string", because it appears first.                              */
 
  // empty 
  blank	=	( cr | lf | tab | space ) +;
  comment = (comment_line | comment_block | comment_line_eof);


/* keywords */
  // types 
  kw_const = 'const';
  kw_interger = 'inteiro';
  kw_real = 'real';
  kw_bool =  'booleano';

  // type values
  kw_true  =  'verdadeiro';
  kw_false =  'falso';

  // reserved
  kw_entry = 'entrada';
  kw_if   = 'se';
  kw_then = 'entao';
  kw_else = 'senao';

  // Bool operators
  kw_and  = 'e';
  kw_not  = 'nao';
  kw_or   = 'ou';

  kw_lambda = 'lambda';
  
/* punctuators */
  plus    = '+';
  minus   = '-';
  mult    =	'*';
  div     = '/';
  mod     = '%';
  l_paren = '(';
  r_paren = ')';
  l_brack = '[';
  r_brack = ']';
  pipe = '|';
  colon = ':';

  eq	= '=';
  lt	= '<';
  gt	= '>';



  // digits are not allowed in identifier
  // neither can have accents, weird chars and can't be no keyword
	identifier	=	nondigit+;
  

  // arithmetic
  number_int  = digit+;
  number_frac =  digit+ ',' digit+;
  number_bin  = '0b' bin_digit+; 

Ignored Tokens

  comment,
  blank;


//+-------------------------------------------------------------+
//|  Concrete Syntax Tree
//+-------------------------------------------------------------+

Productions
  program = decl_func*;

  decl_func =  kw_entry? [lp1]:l_paren type identifier [lp2]:l_paren params [rp2]:r_paren colon [lp3]:l_paren exp [rp3]:r_paren [rp1]:r_paren;
  type  =  {int} kw_interger | {bool} kw_bool | {real} kw_real;

  params  =  /*∆ê*/ | {single} param | {multiple} param pipe params;
  param   =  {type} type identifier | {signature} signature;

  signature =  type identifier l_paren signature_params r_paren;

  signature_params  =  | {single} signature_param | {multiple} signature_param pipe signature_params;
  signature_param = {type} type | {signature} signature;


  // @question is this supposed to be the tokens right, so a binary number should be valid 'exp', correct ?
  exp = {bin} number_bin |  {frac} number_frac | {int} number_int | {true} kw_true | {false} kw_false
    | {block} block_exp
    | {call} func_call  
    | {lambda}func_lambda
    | {negative} minus exp
    | {if} kw_if l_paren [test]:exp r_paren kw_then [if]:exp kw_else [else]:exp
    | {plus} [left]:exp plus [right]:exp
    | {minus} [left]:exp minus [right]:exp
    | {mult} [left]:exp mult [right]:exp
    | {div} [left]:exp div [right]:exp
    | {mod} [left]:exp mod [right]:exp
    | {eq} [left]:exp eq [right]:exp
    | {lt} [left]:exp lt [right]:exp
    | {gt} [left]:exp gt [right]:exp
    | {not} kw_not [right]:exp
    | {and} [left]:exp kw_and [right]:exp
    | {or} [left]:exp kw_or [right]:exp;

  block_exp = {block} l_paren  decl_const* [exp1]:exp r_paren;
  decl_const = [lp1]:l_paren kw_const type identifier [lp2]:l_paren exp [rp2]:r_paren [rp1]:r_paren;

  func_call = identifier l_paren list_exp r_paren;
  func_lambda = [lp1]:l_paren kw_lambda  [lp2]:l_paren list_ids  [rp2]:r_paren colon [lp3]:l_paren exp [rp3]:r_paren l_brack list_exp r_brack [rp1]:r_paren;


  list_ids  =  | {single} identifier | {multiple} identifier pipe list_ids;
  list_exp  =  | {single} exp | {multiple} exp pipe list_exp;